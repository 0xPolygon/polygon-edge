package ibft

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/0xPolygon/polygon-edge/crypto"
	"google.golang.org/protobuf/proto"

	"github.com/0xPolygon/polygon-edge/types"
	protoIBFT "github.com/Trapesys/go-ibft/messages/proto"
)

//	Verifier impl for go-ibft

func (i *Ibft) IsValidBlock(proposal []byte) bool {
	var (
		latestHeader      = i.blockchain.Header()
		latestBlockNumber = latestHeader.Number
		newBlock          = &types.Block{}
	)

	// retrieve the newBlock proposal
	if err := newBlock.UnmarshalRLP(proposal); err != nil {
		i.logger.Error("IsValidBlock: failed to unmarshal newBlock", "err", err)

		return false
	}

	//	TODO: latestBlockNumber was i.state.Sequence
	if newBlock.Number() != latestBlockNumber+1 {
		i.logger.Error(
			"sequence not correct",
			"block", newBlock.Number,
			"sequence", latestBlockNumber+1,
		)

		return false
	}

	snap, err := i.getSnapshot(latestBlockNumber)
	if err != nil {
		i.logger.Error("snapshot not found", "err", err)

		return false
	}

	//	TODO: just verify the header, not the proposer (again)
	if err := i.verifyHeaderImpl(snap, latestHeader, newBlock.Header); err != nil {
		i.logger.Error("block header verification failed", "err", err)

		return false
	}

	if err := i.blockchain.VerifyPotentialBlock(newBlock); err != nil {
		i.logger.Error("newBlock verification failed", "err", err)
		i.handleStateErr(errBlockVerificationFailed)

		return false
	}

	if hookErr := i.runHook(VerifyBlockHook, newBlock.Number(), newBlock); hookErr != nil {
		if errors.As(hookErr, &errBlockVerificationFailed) {
			i.logger.Error("block verification failed, block at the end of epoch has transactions")
		} else {
			i.logger.Error(fmt.Sprintf("Unable to run hook %s, %v", VerifyBlockHook, hookErr))
		}

		return false
	}

	return true
}

//	TODO: move as helper in go-ibft
func copyMsg(m *protoIBFT.Message) *protoIBFT.Message {
	mm, _ := proto.Clone(m).(*protoIBFT.Message)
	return mm
}

func (i *Ibft) IsValidSender(msg *protoIBFT.Message) bool {
	copyMsg := copyMsg(msg)
	copyMsg.Signature = nil

	raw, err := proto.Marshal(copyMsg)
	if err != nil {
		panic("proto marshal")
	}

	validatorAddress, err := ecrecoverImpl(msg.Signature, raw)
	if err != nil {
		panic("ecrecover impl")
	}

	if !bytes.Equal(msg.From, validatorAddress.Bytes()) {
		return false
	}

	return true
}

func (i *Ibft) IsProposer(id []byte, height, round uint64) bool {
	//	TODO: maybe this should just be i.blockchain.Header()
	//		to fetch the latest header available, because fetching
	//		the previousProposer from any earlier block does not make much sense
	//		and it's also not how things work in the old version
	previousHeader, _ := i.blockchain.GetHeaderByNumber(height - 1)

	previousProposer := i.getProposer(previousHeader)

	nextProposer := i.currentValidatorSet.CalcProposer(round, previousProposer)

	if !bytes.Equal(nextProposer.Bytes(), id) {
		return false
	}

	return true
}

func (i *Ibft) IsValidProposalHash(proposal, hash []byte) bool {
	newBlock := &types.Block{}
	if err := newBlock.UnmarshalRLP(proposal); err != nil {
		i.logger.Error("IsValidProposalHash: unable to unmarshal proposal", "err", err)

		return false
	}

	blockHash := newBlock.Header.Hash.Bytes()
	if !bytes.Equal(blockHash, hash) {
		return false
	}

	return true
}

func (i *Ibft) IsValidCommittedSeal(proposalHash, seal []byte) bool {
	commitHash := crypto.Keccak256(proposalHash, []byte{byte(protoIBFT.MessageType_COMMIT)})

	validatorAddress, err := ecrecoverImpl(seal, commitHash)
	if err != nil {
		i.logger.Error("unable to recover seal", "err", err)

		return false
	}

	//	TODO: do I need to check if the validatorAddress is in the currentValidatorSet ?
	if !i.currentValidatorSet.Includes(validatorAddress) {
		i.logger.Error("committed seal generated by validator not in the current set")

		return false
	}

	return true
}

//	helpers

func (i *Ibft) getProposer(header *types.Header) types.Address {
	if header.Number == 0 {
		return types.Address{}
	}

	proposer, _ := ecrecoverFromHeader(header)

	return proposer
}
