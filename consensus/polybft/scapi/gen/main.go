package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/umbracle/ethgo/abi"
)

type entry struct {
	Name string
	Data string
}

func main() {
	trackMethods := map[string]struct{}{
		"currentCheckpointBlockNumber": {},
		"submit":                       {},
		"commit":                       {},
		"execute":                      {},
		"uptime":                       {},
		"commitEpoch":                  {},
		"currentEpochId":               {},
		"getCurrentValidatorSet":       {},
		"getValidator":                 {},
		"counter":                      {},
		"lastCommittedId":              {},
	}

	trackEvents := map[string]struct{}{
		"StateSynced":   {},
		"L2StateSynced": {},
	}

	var methods, events []*entry

	handler := func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if ext := filepath.Ext(path); ext != ".json" {
			// skip non-json files
			return nil
		}

		if strings.HasSuffix(path, ".dbg.json") {
			// skip hardhat debug files
			return nil
		}

		data, err := ioutil.ReadFile(path)
		if err != nil {
			return err
		}

		var artifact struct {
			Abi *abi.ABI
		}

		if err := json.Unmarshal(data, &artifact); err != nil {
			return err
		}

		// read functions
		for _, method := range artifact.Abi.Methods {
			if _, ok := trackMethods[method.Name]; ok {
				methods = append(methods, &entry{
					Name: strings.Title(method.Name),
					Data: encodeMethod(method),
				})
			}
		}

		// read events
		for _, event := range artifact.Abi.Events {
			if _, ok := trackEvents[event.Name]; ok {
				events = append(events, &entry{
					Name: strings.Title(event.Name),
					Data: encodeEvent(event),
				})
			}
		}

		return nil
	}

	if err := filepath.Walk("core-contracts/artifacts/contracts", handler); err != nil {
		os.Exit(1)
	}

	tmpl, err := template.New("").Parse(tmpl)
	if err != nil {
		panic(err)
	}

	input := map[string]interface{}{
		"Methods": methods,
		"Events":  events,
	}

	var tpl bytes.Buffer
	if err := tmpl.Execute(&tpl, input); err != nil {
		panic(err)
	}

	output, err := format.Source([]byte(tpl.String()))
	if err != nil {
		panic(err)
	}

	fmt.Println(string(output))
}

var tmpl = `// Code generated by scapi. DO NOT EDIT.
package scapi

import "github.com/umbracle/ethgo/abi"

// Methods
var (
	{{range $element := .Methods}}
		{{$element.Name}}Fn = abi.MustNewMethod("{{$element.Data}}")
	{{end}}
)

// Events
var (
	{{range $element := .Events}}
		{{$element.Name}}Event = abi.MustNewEvent("{{$element.Data}}")
	{{end}}
)`

func encodeEvent(e *abi.Event) string {
	return "event " + e.Name + "(" + encodeTupleElems(e.Inputs) + ")"
}

func encodeMethod(m *abi.Method) string {
	str := "function " + m.Name
	str += "(" + encodeTupleElems(m.Inputs) + ")"

	if len(m.Outputs.TupleElems()) != 0 {
		str += " returns (" + encodeTupleElems(m.Outputs) + ")"
	}

	return str
}

func encodeTupleElems(m *abi.Type) string {
	// we need to remove the extra 'tuple()' enclosing that
	// represents the function and event call itself.
	str := m.Format(true)
	str = strings.TrimPrefix(str, "tuple(")
	str = strings.TrimSuffix(str, ")")

	return str
}
