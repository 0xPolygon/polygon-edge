package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"github.com/0xPolygon/polygon-edge/consensus/polybft/contractsapi/artifact"
	"github.com/umbracle/ethgo/abi"
)

func main() {
	cases := []struct {
		contract string
		methods  []string
		events   []string
	}{
		{
			"child/StateReceiver",
			[]string{
				"commit",
				"execute",
			},
			[]string{
				"StateSyncResult",
				"NewCommitment",
			},
		},
		{
			"child/ChildValidatorSet",
			[]string{
				"commitEpoch",
			},
			[]string{},
		},
		{
			"root/StateSender",
			[]string{
				"syncState",
			},
			[]string{
				"StateSynced",
			},
		},
		{
			"root/CheckpointManager",
			[]string{
				"submit",
			},
			[]string{},
		},
	}

	rr := render{}

	res := []string{}

	for _, c := range cases {
		base := filepath.Base(c.contract)

		contract, err := ioutil.ReadFile("./core-contracts/artifacts/contracts/" + c.contract + ".sol/" + base + ".json")
		if err != nil {
			panic(err)
		}

		ar, err := artifact.DecodeArtifact(contract)
		if err != nil {
			panic(err)
		}

		for _, method := range c.methods {
			res = append(res, rr.Gen(ar.Abi.Methods[method]))
		}

		for _, event := range c.events {
			res = append(res, rr.GenEvent(ar.Abi.Events[event]))
		}
	}

	str := `// Code generated by scapi/gen. DO NOT EDIT.
package contractsapi

import (
	"math/big"

	"github.com/0xPolygon/polygon-edge/types"
	"github.com/umbracle/ethgo/abi"
	"github.com/umbracle/ethgo"
)

var (
	_ = big.NewInt
	_ = types.Address{}
	_ = ethgo.Log{}
)

`

	str += strings.Join(res, "\n")

	output, err := format.Source([]byte(str))
	if err != nil {
		fmt.Println(str)
		panic(err)
	}

	if err := ioutil.WriteFile("./consensus/polybft/contractsapi/contractsapi.go", output, 0600); err != nil {
		panic(err)
	}
}

type render struct {
}

func genType(name string, obj *abi.Type, res *[]string) string {
	if obj.Kind() != abi.KindTuple {
		panic("BUG: Not expected")
	}

	name = strings.Title(name)

	str := []string{
		"type " + name + " struct {",
	}

	for _, tupleElem := range obj.TupleElems() {
		elem := tupleElem.Elem

		var typ string
		if elem.Kind() == abi.KindTuple {
			// Struct
			typ = genType(tupleElem.Name, tupleElem.Elem, res)
		} else if elem.Kind() == abi.KindSlice && elem.Elem().Kind() == abi.KindTuple {
			// []Struct
			typ = "[]" + genType(tupleElem.Name, elem.Elem(), res)
		} else if elem.Kind() == abi.KindArray && elem.Elem().Kind() == abi.KindTuple {
			// [n]Struct
			typ = "[" + strconv.Itoa(elem.Size()) + "]" + genType(tupleElem.Name, elem.Elem(), res)
		} else if elem.Kind() == abi.KindAddress {
			// for address use the native `types.Address` type instead of `ethgo.Address`. Note that
			// this only works for simple types and not for []address inputs. This is good enough since
			// there are no kinds like that in our smart contracts.
			typ = "types.Address"
		} else {
			// for the rest of the types use the go type returned by abi
			typ = elem.GoType().String()
		}

		// []byte and [n]byte get rendered as []uint68 and [n]uint8, since we do not have any
		// uint8 internally in polybft, we can use regexp to replace those values with the
		// correct byte representation
		typ = strings.Replace(typ, "[32]uint8", "types.Hash", -1)
		typ = strings.Replace(typ, "]uint8", "]byte", -1)

		// Replacement of Id for ID to make the linter happy
		fieldName := strings.Title(tupleElem.Name)
		fieldName = strings.Replace(fieldName, "Id", "ID", -1)

		str = append(str, fmt.Sprintf("%s %s `abi:\"%s\"`", fieldName, typ, tupleElem.Name))
	}

	str = append(str, "}")
	*res = append(*res, strings.Join(str, "\n"))

	return name
}

func (r *render) GenEvent(event *abi.Event) string {
	name := event.Name + "Event"

	res := []string{}
	genType(name, event.Inputs, &res)

	// write encode/decode functions
	tmplStr := `
var (
	{{.Name}}Type = abi.MustNewEvent("{{.Type}}") //nolint:all
)

{{range .Structs}}
	{{.}}
{{ end }}

func ({{.Sig}} *{{.TName}}) ParseLog(log *ethgo.Log) error {
	return decodeEvent({{.Name}}Type, log, {{.Sig}})
}`

	eventType := "event " + event.Name + "(" + encodeFuncTuple(event.Inputs) + ")"

	inputs := map[string]interface{}{
		"Structs": res,
		"Type":    eventType,
		"Sig":     string(name[0]),
		"Name":    name,
		"TName":   strings.Title(name),
	}

	return renderTmpl(tmplStr, inputs)
}

func (r *render) Gen(method *abi.Method) string {
	name := method.Name

	res := []string{}
	genType(name, method.Inputs, &res)

	// write encode/decode functions
	tmplStr := `
var (
	{{.Name}}Type = abi.MustNewMethod("{{.Type}}") //nolint:all
)

{{range .Structs}}
	{{.}}
{{ end }}

func ({{.Sig}} *{{.TName}}) EncodeAbi() ([]byte, error) {
	return {{.Name}}Type.Encode({{.Sig}})
}

func ({{.Sig}} *{{.TName}}) DecodeAbi(buf []byte) error {
	return decodeMethod({{.Name}}Type, buf, {{.Sig}})
}`

	methodType := "function " + method.Name + "("
	if len(method.Inputs.TupleElems()) != 0 {
		methodType += encodeFuncTuple(method.Inputs)
	}

	methodType += ")"

	if len(method.Outputs.TupleElems()) != 0 {
		methodType += "(" + encodeFuncTuple(method.Outputs) + ")"
	}

	inputs := map[string]interface{}{
		"Structs": res,
		"Type":    methodType,
		"Sig":     string(name[0]),
		"Name":    name,
		"TName":   strings.Title(name),
	}

	return renderTmpl(tmplStr, inputs)
}

func renderTmpl(tmplStr string, inputs map[string]interface{}) string {
	tmpl, err := template.New("name").Parse(tmplStr)
	if err != nil {
		panic(fmt.Sprintf("BUG: Failed to load template: %v", err))
	}

	var tpl bytes.Buffer
	if err = tmpl.Execute(&tpl, inputs); err != nil {
		panic(fmt.Sprintf("BUG: Failed to render template: %v", err))
	}

	return tpl.String()
}

func encodeFuncTuple(t *abi.Type) string {
	if t.Kind() != abi.KindTuple {
		panic("BUG: Kind different than tuple not expected")
	}

	str := t.Format(true)
	str = strings.TrimPrefix(str, "tuple(")
	str = strings.TrimSuffix(str, ")")

	return str
}
